type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
};

declare class CancelError extends Error {
    constructor(message: string);
    get isCancelled(): boolean;
}
interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;
    (cancelHandler: () => void): void;
}
declare class CancelablePromise<T> implements Promise<T> {
    readonly [Symbol.toStringTag]: string;
    private _isResolved;
    private _isRejected;
    private _isCancelled;
    private readonly _cancelHandlers;
    private readonly _promise;
    private _resolve?;
    private _reject?;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancel) => void);
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | null): Promise<T>;
    cancel(): void;
    get isCancelled(): boolean;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;
type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    CREDENTIALS: 'include' | 'omit' | 'same-origin';
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
    ENCODE_PATH?: (path: string) => string;
};
declare const OpenAPI: OpenAPIConfig;

declare abstract class BaseHttpRequest {
    readonly config: OpenAPIConfig;
    constructor(config: OpenAPIConfig);
    abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}

/**
 * These codes provide more granular error information beyond just the HTTP
 * status code of the response.
 */
declare enum AptosTapErrorCode {
    YEAH_NAH_YEAH_YEAH_YEAH_NAH_YEAH_NAH = "YeahNahYeahYeahYeahNahYeahNah",
    INVALID_REQUEST = "InvalidRequest",
    ACCOUNT_DOES_NOT_EXIST = "AccountDoesNotExist",
    REJECTED = "Rejected",
    SOURCE_IP_MISSING = "SourceIpMissing",
    TRANSACTION_FAILED = "TransactionFailed",
    ENDPOINT_NOT_ENABLED = "EndpointNotEnabled",
    APTOS_API_ERROR = "AptosApiError",
    BYPASSER_ERROR = "BypasserError",
    CHECKER_ERROR = "CheckerError",
    STORAGE_ERROR = "StorageError",
    FUNDER_ACCOUNT_PROBLEM = "FunderAccountProblem",
    TRANSACTION_TIMED_OUT = "TransactionTimedOut",
    SERIALIZATION_ERROR = "SerializationError",
    SERVER_OVERLOADED = "ServerOverloaded",
    WEB_FRAMEWORK_ERROR = "WebFrameworkError"
}

declare enum RejectionReasonCode {
    HEHE = "Hehe",
    ACCOUNT_ALREADY_EXISTS = "AccountAlreadyExists",
    IP_USAGE_LIMIT_EXHAUSTED = "IpUsageLimitExhausted",
    IP_IN_BLOCKLIST = "IpInBlocklist",
    REQUEST_FROM_VPN = "RequestFromVpn",
    REQUEST_FROM_CLOUD = "RequestFromCloud",
    MAGIC_HEADER_INCORRECT = "MagicHeaderIncorrect",
    CAPTCHA_INVALID = "CaptchaInvalid",
    AUTH_TOKEN_INVALID = "AuthTokenInvalid"
}

type RejectionReason = {
    reason: string;
    code: RejectionReasonCode;
};

/**
 * This is the generic struct we use for all API errors, it contains a string
 * message and a service specific error code.
 */
type AptosTapError = {
    /**
     * A message describing the error
     */
    message: string;
    error_code: AptosTapErrorCode;
    /**
     * If we're returning a 403 because we're rejecting the mint request, this
     * contains additional reasons why.
     */
    rejection_reasons: Array<RejectionReason>;
    /**
     * Submitted transaction hashes, if it got to that point.
     */
    txn_hashes: Array<string>;
};

declare class CaptchaService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Initiate captcha flow
     * With this endpoint you can initiate a captcha flow. The response will
     * contain an image (the captcha to solve) in the body and a code in the
     * header that you must include in the call to `/fund`. This endpoint is
     * only relevant if the CaptchaChecker is enabled.
     * @returns binary
     * @returns AptosTapError
     * @throws ApiError
     */
    requestCaptcha(): CancelablePromise<Blob | AptosTapError>;
}

type FundRequest = {
    /**
     * If not set, the default is the preconfigured max funding amount. If set,
     * we will use this amount instead assuming it is < than the maximum,
     * otherwise we'll just use the maximum.
     */
    amount?: number;
    /**
     * Either this or `address` / `pub_key` must be provided.
     */
    auth_key?: string;
    /**
     * Either this or `auth_key` / `pub_key` must be provided.
     */
    address?: string;
    /**
     * Either this or `auth_key` / `address` must be provided.
     */
    pub_key?: string;
};

type FundResponse = {
    txn_hashes: Array<string>;
};

declare class FundService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Funds an account
     * With this endpoint a user can create and fund an account. Depending on
     * the configured funding backend, this may do different things under the
     * hood (e.g. minting vs transferring) and have different funding semantics
     * (e.g. whether it will fund an account if it already exists).
     * @returns FundResponse
     * @returns AptosTapError
     * @throws ApiError
     */
    fund({ requestBody, }: {
        requestBody: FundRequest;
    }): CancelablePromise<FundResponse | AptosTapError>;
    /**
     * Check whether a given requester is eligible to be funded
     * This function runs only the various eligibility checks that we perform
     * in `fund` without actually funding the account or writing anything to
     * storage. If the request is valid it returns an empty 200. If it is invalid
     * it returns a 400 or 403 with an explanation in the response body.
     * @returns any
     * @returns AptosTapError
     * @throws ApiError
     */
    isEligible({ requestBody, }: {
        requestBody: FundRequest;
    }): CancelablePromise<any | AptosTapError>;
}

declare class GeneralService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Show OpenAPI explorer
     * Provides a UI that you can use to explore the API. You can also
     * retrieve the API directly at `/spec.yaml` and `/spec.json`.
     * @returns string
     * @throws ApiError
     */
    spec(): CancelablePromise<string>;
    /**
     * Check API health
     * Basic endpoint that always returns Ok for health.
     * @returns string
     * @throws ApiError
     */
    root(): CancelablePromise<string>;
}

type HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;
declare class AptosFaucetClient {
    readonly captcha: CaptchaService;
    readonly fund: FundService;
    readonly general: GeneralService;
    readonly request: BaseHttpRequest;
    constructor(config?: Partial<OpenAPIConfig>, HttpRequest?: HttpRequestConstructor);
}

type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
};

declare class ApiError extends Error {
    readonly url: string;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
    readonly request: ApiRequestOptions;
    constructor(request: ApiRequestOptions, response: ApiResult, message: string);
}

declare const $AptosTapError: {
    readonly description: "This is the generic struct we use for all API errors, it contains a string\n    message and a service specific error code.";
    readonly properties: {
        readonly message: {
            readonly type: "string";
            readonly description: "A message describing the error";
            readonly isRequired: true;
        };
        readonly error_code: {
            readonly type: "all-of";
            readonly contains: readonly [{
                readonly type: "AptosTapErrorCode";
            }];
            readonly isRequired: true;
        };
        readonly rejection_reasons: {
            readonly type: "array";
            readonly contains: {
                readonly type: "RejectionReason";
            };
            readonly isRequired: true;
        };
        readonly txn_hashes: {
            readonly type: "array";
            readonly contains: {
                readonly type: "string";
            };
            readonly isRequired: true;
        };
    };
};

declare const $AptosTapErrorCode: {
    readonly type: "Enum";
};

declare const $FundRequest: {
    readonly properties: {
        readonly amount: {
            readonly type: "number";
            readonly description: "If not set, the default is the preconfigured max funding amount. If set,\n            we will use this amount instead assuming it is < than the maximum,\n            otherwise we'll just use the maximum.";
            readonly format: "uint64";
        };
        readonly auth_key: {
            readonly type: "string";
            readonly description: "Either this or `address` / `pub_key` must be provided.";
        };
        readonly address: {
            readonly type: "string";
            readonly description: "Either this or `auth_key` / `pub_key` must be provided.";
        };
        readonly pub_key: {
            readonly type: "string";
            readonly description: "Either this or `auth_key` / `address` must be provided.";
        };
    };
};

declare const $FundResponse: {
    readonly properties: {
        readonly txn_hashes: {
            readonly type: "array";
            readonly contains: {
                readonly type: "string";
            };
            readonly isRequired: true;
        };
    };
};

declare const $RejectionReason: {
    readonly properties: {
        readonly reason: {
            readonly type: "string";
            readonly isRequired: true;
        };
        readonly code: {
            readonly type: "RejectionReasonCode";
            readonly isRequired: true;
        };
    };
};

declare const $RejectionReasonCode: {
    readonly type: "Enum";
};

export { $AptosTapError, $AptosTapErrorCode, $FundRequest, $FundResponse, $RejectionReason, $RejectionReasonCode, ApiError, AptosFaucetClient, AptosTapError, AptosTapErrorCode, BaseHttpRequest, CancelError, CancelablePromise, CaptchaService, FundRequest, FundResponse, FundService, GeneralService, OpenAPI, OpenAPIConfig, RejectionReason, RejectionReasonCode };
