// src/core/BaseHttpRequest.ts
var BaseHttpRequest = class {
  constructor(config) {
    this.config = config;
  }
};

// src/core/request.ts
import axios from "axios";
import FormData from "form-data";

// src/core/ApiError.ts
var ApiError = class extends Error {
  constructor(request2, response, message) {
    super(message);
    this.name = "ApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.body = response.body;
    this.request = request2;
  }
};

// src/core/CancelablePromise.ts
var CancelError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CancelError";
  }
  get isCancelled() {
    return true;
  }
};
var CancelablePromise = class {
  constructor(executor) {
    this._isResolved = false;
    this._isRejected = false;
    this._isCancelled = false;
    this._cancelHandlers = [];
    this._promise = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
      const onResolve = (value) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isResolved = true;
        this._resolve?.(value);
      };
      const onReject = (reason) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isRejected = true;
        this._reject?.(reason);
      };
      const onCancel = (cancelHandler) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._cancelHandlers.push(cancelHandler);
      };
      Object.defineProperty(onCancel, "isResolved", {
        get: () => this._isResolved
      });
      Object.defineProperty(onCancel, "isRejected", {
        get: () => this._isRejected
      });
      Object.defineProperty(onCancel, "isCancelled", {
        get: () => this._isCancelled
      });
      return executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel() {
    if (this._isResolved || this._isRejected || this._isCancelled) {
      return;
    }
    this._isCancelled = true;
    if (this._cancelHandlers.length) {
      try {
        for (const cancelHandler of this._cancelHandlers) {
          cancelHandler();
        }
      } catch (error) {
        console.warn("Cancellation threw an error", error);
        return;
      }
    }
    this._cancelHandlers.length = 0;
    this._reject?.(new CancelError("Request aborted"));
  }
  get isCancelled() {
    return this._isCancelled;
  }
};
Symbol.toStringTag;

// src/core/request.ts
var CookieJar = class {
  constructor(jar2 = /* @__PURE__ */ new Map()) {
    this.jar = jar2;
  }
  setCookie(url, cookieStr) {
    const key = url.origin.toLowerCase();
    if (!this.jar.has(key)) {
      this.jar.set(key, []);
    }
    const cookie = CookieJar.parse(cookieStr);
    this.jar.set(key, [...this.jar.get(key)?.filter((c) => c.name !== cookie.name) || [], cookie]);
  }
  getCookies(url) {
    const key = url.origin.toLowerCase();
    if (!this.jar.get(key)) {
      return [];
    }
    return this.jar.get(key)?.filter((cookie) => !cookie.expires || cookie.expires > /* @__PURE__ */ new Date()) || [];
  }
  static parse(str) {
    if (typeof str !== "string") {
      throw new Error("argument str must be a string");
    }
    const parts = str.split(";").map((part) => part.trim());
    let cookie;
    if (parts.length > 0) {
      const [name, value] = parts[0].split("=");
      if (!name || !value) {
        throw new Error("Invalid cookie");
      }
      cookie = {
        name,
        value
      };
    } else {
      throw new Error("Invalid cookie");
    }
    parts.slice(1).forEach((part) => {
      const [name, value] = part.split("=");
      if (!name.trim()) {
        throw new Error("Invalid cookie");
      }
      const nameLow = name.toLowerCase();
      const val = value?.charAt(0) === "'" || value?.charAt(0) === '"' ? value?.slice(1, -1) : value;
      if (nameLow === "expires") {
        cookie.expires = new Date(val);
      }
      if (nameLow === "path") {
        cookie.path = val;
      }
      if (nameLow === "samesite") {
        if (val !== "Lax" && val !== "None" && val !== "Strict") {
          throw new Error("Invalid cookie SameSite value");
        }
        cookie.sameSite = val;
      }
      if (nameLow === "secure") {
        cookie.secure = true;
      }
    });
    return cookie;
  }
};
var jar = new CookieJar();
axios.interceptors.response.use((response) => {
  if (Array.isArray(response.headers["set-cookie"])) {
    response.headers["set-cookie"].forEach((c) => {
      jar.setCookie(new URL(response.config.url), c);
    });
  }
  return response;
});
axios.interceptors.request.use(function(config) {
  const cookies = jar.getCookies(new URL(config.url));
  if (cookies?.length > 0 && config.headers) {
    config.headers.cookie = cookies.map((cookie) => `${cookie.name}=${cookie.value}`).join("; ");
  }
  return config;
});
var isDefined = (value) => {
  return value !== void 0 && value !== null;
};
var isString = (value) => {
  return typeof value === "string";
};
var isStringWithValue = (value) => {
  return isString(value) && value !== "";
};
var isBlob = (value) => {
  return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
var isFormData = (value) => {
  return value instanceof FormData;
};
var isSuccess = (status) => {
  return status >= 200 && status < 300;
};
var base64 = (str) => {
  return btoa(str);
};
var getQueryString = (params) => {
  const qs = [];
  const append = (key, value) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };
  const process = (key, value) => {
    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach((v) => {
          process(key, v);
        });
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([k, v]) => {
          process(`${key}[${k}]`, v);
        });
      } else {
        append(key, value);
      }
    }
  };
  Object.entries(params).forEach(([key, value]) => {
    process(key, value);
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
};
var getUrl = (config, options) => {
  const encoder = config.ENCODE_PATH || encodeURI;
  const path = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {
    if (options.path?.hasOwnProperty(group)) {
      return encoder(String(options.path[group]));
    }
    return substring;
  });
  const url = `${config.BASE}${path}`;
  if (options.query) {
    return `${url}${getQueryString(options.query)}`;
  }
  return url;
};
var getFormData = (options) => {
  if (options.formData) {
    const formData = new FormData();
    const process = (key, value) => {
      if (isString(value) || isBlob(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };
    Object.entries(options.formData).filter(([_, value]) => isDefined(value)).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => process(key, v));
      } else {
        process(key, value);
      }
    });
    return formData;
  }
  return void 0;
};
var resolve = async (options, resolver) => {
  if (typeof resolver === "function") {
    return resolver(options);
  }
  return resolver;
};
var getHeaders = async (config, options, formData) => {
  const token = await resolve(options, config.TOKEN);
  const username = await resolve(options, config.USERNAME);
  const password = await resolve(options, config.PASSWORD);
  const additionalHeaders = await resolve(options, config.HEADERS);
  const formHeaders = typeof formData?.getHeaders === "function" && formData?.getHeaders() || {};
  const headers = Object.entries({
    Accept: "application/json",
    ...additionalHeaders,
    ...options.headers,
    ...formHeaders
  }).filter(([_, value]) => isDefined(value)).reduce((headers2, [key, value]) => ({
    ...headers2,
    [key]: String(value)
  }), {});
  if (isStringWithValue(token)) {
    headers["Authorization"] = `Bearer ${token}`;
  }
  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = base64(`${username}:${password}`);
    headers["Authorization"] = `Basic ${credentials}`;
  }
  if (options.body) {
    if (options.mediaType) {
      headers["Content-Type"] = options.mediaType;
    } else if (isBlob(options.body)) {
      headers["Content-Type"] = options.body.type || "application/octet-stream";
    } else if (isString(options.body)) {
      headers["Content-Type"] = "text/plain";
    } else if (!isFormData(options.body)) {
      headers["Content-Type"] = "application/json";
    }
  }
  return headers;
};
var getRequestBody = (options) => {
  if (options.body) {
    return options.body;
  }
  return void 0;
};
var sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
  const source = axios.CancelToken.source();
  const requestConfig = {
    url,
    headers,
    data: body ?? formData,
    method: options.method,
    withCredentials: config.WITH_CREDENTIALS,
    cancelToken: source.token
  };
  const isBCS = Object.keys(config.HEADERS || {}).filter((k) => k.toLowerCase() === "accept").map((k) => config.HEADERS[k]).includes("application/x-bcs");
  if (isBCS) {
    requestConfig.responseType = "arraybuffer";
  }
  onCancel(() => source.cancel("The user aborted a request."));
  try {
    return await axios.request(requestConfig);
  } catch (error) {
    const axiosError = error;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
};
var getResponseHeader = (response, responseHeader) => {
  if (responseHeader) {
    const content = response.headers[responseHeader];
    if (isString(content)) {
      return content;
    }
  }
  return void 0;
};
var getResponseBody = (response) => {
  if (response.status !== 204) {
    return response.data;
  }
  return void 0;
};
var catchErrorCodes = (options, result) => {
  const errors = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    429: "Too Many Requests",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
    ...options.errors
  };
  const error = errors[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }
  if (!result.ok) {
    throw new ApiError(options, result, "Generic Error");
  }
};
var request = (config, options) => {
  return new CancelablePromise(async (resolve2, reject, onCancel) => {
    try {
      const url = getUrl(config, options);
      const formData = getFormData(options);
      const body = getRequestBody(options);
      const headers = await getHeaders(config, options, formData);
      if (!onCancel.isCancelled) {
        const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
        const responseBody = getResponseBody(response);
        const responseHeader = getResponseHeader(response, options.responseHeader);
        const result = {
          url,
          ok: isSuccess(response.status),
          status: response.status,
          statusText: response.statusText,
          body: responseHeader ?? responseBody
        };
        catchErrorCodes(options, result);
        const out = result.body;
        try {
          out["__headers"] = response.headers;
        } catch (_) {
        }
        resolve2(out);
      }
    } catch (error) {
      reject(error);
    }
  });
};

// src/core/AxiosHttpRequest.ts
var AxiosHttpRequest = class extends BaseHttpRequest {
  constructor(config) {
    super(config);
  }
  /**
   * Request method
   * @param options The request options from the service
   * @returns CancelablePromise<T>
   * @throws ApiError
   */
  request(options) {
    return request(this.config, options);
  }
};

// src/services/CaptchaService.ts
var CaptchaService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Initiate captcha flow
   * With this endpoint you can initiate a captcha flow. The response will
   * contain an image (the captcha to solve) in the body and a code in the
   * header that you must include in the call to `/fund`. This endpoint is
   * only relevant if the CaptchaChecker is enabled.
   * @returns binary
   * @returns AptosTapError
   * @throws ApiError
   */
  requestCaptcha() {
    return this.httpRequest.request({
      method: "GET",
      url: "/request_captcha"
    });
  }
};

// src/services/FundService.ts
var FundService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Funds an account
   * With this endpoint a user can create and fund an account. Depending on
   * the configured funding backend, this may do different things under the
   * hood (e.g. minting vs transferring) and have different funding semantics
   * (e.g. whether it will fund an account if it already exists).
   * @returns FundResponse
   * @returns AptosTapError
   * @throws ApiError
   */
  fund({
    requestBody
  }) {
    return this.httpRequest.request({
      method: "POST",
      url: "/fund",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Check whether a given requester is eligible to be funded
   * This function runs only the various eligibility checks that we perform
   * in `fund` without actually funding the account or writing anything to
   * storage. If the request is valid it returns an empty 200. If it is invalid
   * it returns a 400 or 403 with an explanation in the response body.
   * @returns any
   * @returns AptosTapError
   * @throws ApiError
   */
  isEligible({
    requestBody
  }) {
    return this.httpRequest.request({
      method: "POST",
      url: "/is_eligible",
      body: requestBody,
      mediaType: "application/json"
    });
  }
};

// src/services/GeneralService.ts
var GeneralService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Show OpenAPI explorer
   * Provides a UI that you can use to explore the API. You can also
   * retrieve the API directly at `/spec.yaml` and `/spec.json`.
   * @returns string
   * @throws ApiError
   */
  spec() {
    return this.httpRequest.request({
      method: "GET",
      url: "/spec"
    });
  }
  /**
   * Check API health
   * Basic endpoint that always returns Ok for health.
   * @returns string
   * @throws ApiError
   */
  root() {
    return this.httpRequest.request({
      method: "GET",
      url: "/"
    });
  }
};

// src/AptosFaucetClient.ts
var AptosFaucetClient = class {
  constructor(config, HttpRequest = AxiosHttpRequest) {
    this.request = new HttpRequest({
      BASE: config?.BASE ?? "/v1",
      VERSION: config?.VERSION ?? "0.1.0",
      WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,
      CREDENTIALS: config?.CREDENTIALS ?? "include",
      TOKEN: config?.TOKEN,
      USERNAME: config?.USERNAME,
      PASSWORD: config?.PASSWORD,
      HEADERS: config?.HEADERS,
      ENCODE_PATH: config?.ENCODE_PATH
    });
    this.captcha = new CaptchaService(this.request);
    this.fund = new FundService(this.request);
    this.general = new GeneralService(this.request);
  }
};

// src/core/OpenAPI.ts
var OpenAPI = {
  BASE: "/v1",
  VERSION: "0.1.0",
  WITH_CREDENTIALS: false,
  CREDENTIALS: "include",
  TOKEN: void 0,
  USERNAME: void 0,
  PASSWORD: void 0,
  HEADERS: void 0,
  ENCODE_PATH: void 0
};

// src/models/AptosTapErrorCode.ts
var AptosTapErrorCode = /* @__PURE__ */ ((AptosTapErrorCode2) => {
  AptosTapErrorCode2["YEAH_NAH_YEAH_YEAH_YEAH_NAH_YEAH_NAH"] = "YeahNahYeahYeahYeahNahYeahNah";
  AptosTapErrorCode2["INVALID_REQUEST"] = "InvalidRequest";
  AptosTapErrorCode2["ACCOUNT_DOES_NOT_EXIST"] = "AccountDoesNotExist";
  AptosTapErrorCode2["REJECTED"] = "Rejected";
  AptosTapErrorCode2["SOURCE_IP_MISSING"] = "SourceIpMissing";
  AptosTapErrorCode2["TRANSACTION_FAILED"] = "TransactionFailed";
  AptosTapErrorCode2["ENDPOINT_NOT_ENABLED"] = "EndpointNotEnabled";
  AptosTapErrorCode2["APTOS_API_ERROR"] = "AptosApiError";
  AptosTapErrorCode2["BYPASSER_ERROR"] = "BypasserError";
  AptosTapErrorCode2["CHECKER_ERROR"] = "CheckerError";
  AptosTapErrorCode2["STORAGE_ERROR"] = "StorageError";
  AptosTapErrorCode2["FUNDER_ACCOUNT_PROBLEM"] = "FunderAccountProblem";
  AptosTapErrorCode2["TRANSACTION_TIMED_OUT"] = "TransactionTimedOut";
  AptosTapErrorCode2["SERIALIZATION_ERROR"] = "SerializationError";
  AptosTapErrorCode2["SERVER_OVERLOADED"] = "ServerOverloaded";
  AptosTapErrorCode2["WEB_FRAMEWORK_ERROR"] = "WebFrameworkError";
  return AptosTapErrorCode2;
})(AptosTapErrorCode || {});

// src/models/RejectionReasonCode.ts
var RejectionReasonCode = /* @__PURE__ */ ((RejectionReasonCode2) => {
  RejectionReasonCode2["HEHE"] = "Hehe";
  RejectionReasonCode2["ACCOUNT_ALREADY_EXISTS"] = "AccountAlreadyExists";
  RejectionReasonCode2["IP_USAGE_LIMIT_EXHAUSTED"] = "IpUsageLimitExhausted";
  RejectionReasonCode2["IP_IN_BLOCKLIST"] = "IpInBlocklist";
  RejectionReasonCode2["REQUEST_FROM_VPN"] = "RequestFromVpn";
  RejectionReasonCode2["REQUEST_FROM_CLOUD"] = "RequestFromCloud";
  RejectionReasonCode2["MAGIC_HEADER_INCORRECT"] = "MagicHeaderIncorrect";
  RejectionReasonCode2["CAPTCHA_INVALID"] = "CaptchaInvalid";
  RejectionReasonCode2["AUTH_TOKEN_INVALID"] = "AuthTokenInvalid";
  return RejectionReasonCode2;
})(RejectionReasonCode || {});

// src/schemas/$AptosTapError.ts
var $AptosTapError = {
  description: `This is the generic struct we use for all API errors, it contains a string
    message and a service specific error code.`,
  properties: {
    message: {
      type: "string",
      description: `A message describing the error`,
      isRequired: true
    },
    error_code: {
      type: "all-of",
      contains: [{
        type: "AptosTapErrorCode"
      }],
      isRequired: true
    },
    rejection_reasons: {
      type: "array",
      contains: {
        type: "RejectionReason"
      },
      isRequired: true
    },
    txn_hashes: {
      type: "array",
      contains: {
        type: "string"
      },
      isRequired: true
    }
  }
};

// src/schemas/$AptosTapErrorCode.ts
var $AptosTapErrorCode = {
  type: "Enum"
};

// src/schemas/$FundRequest.ts
var $FundRequest = {
  properties: {
    amount: {
      type: "number",
      description: `If not set, the default is the preconfigured max funding amount. If set,
            we will use this amount instead assuming it is < than the maximum,
            otherwise we'll just use the maximum.`,
      format: "uint64"
    },
    auth_key: {
      type: "string",
      description: `Either this or \`address\` / \`pub_key\` must be provided.`
    },
    address: {
      type: "string",
      description: `Either this or \`auth_key\` / \`pub_key\` must be provided.`
    },
    pub_key: {
      type: "string",
      description: `Either this or \`auth_key\` / \`address\` must be provided.`
    }
  }
};

// src/schemas/$FundResponse.ts
var $FundResponse = {
  properties: {
    txn_hashes: {
      type: "array",
      contains: {
        type: "string"
      },
      isRequired: true
    }
  }
};

// src/schemas/$RejectionReason.ts
var $RejectionReason = {
  properties: {
    reason: {
      type: "string",
      isRequired: true
    },
    code: {
      type: "RejectionReasonCode",
      isRequired: true
    }
  }
};

// src/schemas/$RejectionReasonCode.ts
var $RejectionReasonCode = {
  type: "Enum"
};
export {
  $AptosTapError,
  $AptosTapErrorCode,
  $FundRequest,
  $FundResponse,
  $RejectionReason,
  $RejectionReasonCode,
  ApiError,
  AptosFaucetClient,
  AptosTapErrorCode,
  BaseHttpRequest,
  CancelError,
  CancelablePromise,
  CaptchaService,
  FundService,
  GeneralService,
  OpenAPI,
  RejectionReasonCode
};
//# sourceMappingURL=index.mjs.map